# go-5-045布尔型、数字型和字符型

表达式是一种特定的类型的值，当使用了不能一起运算的类型时，就会报错。

只有两个类型相同的值才可以和二元运算符结合

一元运算符只可以用于一个值的操作（作为后缀），

二元运算符可以和两个值或者操作数结合（作为中缀）。

**用在同一个函数里的运算符类型一定要相同**

任何不同类型之间的转换都必须显式说明，

表达式的解析顺序是从左至右

优先级越高的运算符在条件相同的情况下将被优先执行，就像是小学算术，也遵循加个括号优先运算的法则。

## 布尔类型 bool

yes 还有 no 的一种类型，彼此对立。

举个例子

```go
var b bool = true
//用var声明变量 变量的名字b 变量的类型为bool也就是布尔类型 = 真
```

此处b只能为真假，这两个对立关系的变量。

**布尔类型可用作是非判断**，

当两个运算符的类型相同，用 `==`或者`！=`来对这两个运算符进行判断。



示例：

```go
var aVar = 10
aVar != 10 -> true    //此处的 -> 就是 减号 大于号
aVar != 5 -> false    //此处的 -> 表示了一种指向，当函数符合前式的判断的时候，就返回这个箭头值的东西。
```

这个例子表示当不等运算符两边的值相同，也就是都为10的时候会返回 true，否则返回 false。



**逻辑运算符**（非 `!`、和 `&&`、或 `||`），可用做一种逻辑的判断，但是这样的逻辑语句就其本身而言，并不是一个完整的 Go 语句。

这种逻辑的判断可以被用于条件结构里的条件语句，就是，用来写用来判断的条件。



**<u>再看一遍————非 `!`、和 `&&`、或 `||`</u>**     

 shift+\（也就是backspace下面那个按键）可以打出来||

在下文中用 T 来表示符合条件判断的语句，就像是1+1=2这种

用 F 来表示不符合条件判断的语句，就像是1+1=3。

当运用，**非**运算符：`!`

```go
!T -> false  //这里的！T就是表示非T，也就是非此条件
!F -> true
```

非运算符用于取得和布尔值相反的结果。

当运用，**与**  运算符：`&&`

```go
T && T -> true
T && F -> false
F && T -> false
F && F -> false
```

只有当两边的值都为 true 的时候，和运算符的结果才是 true。

当运用，**或**  运算符：`||`

```go
T || T -> true
T || F -> true
F || T -> true
F || F -> false
```

只有当两边的值都为 false 的时候，或运算符的结果才是 false，其中任意一边的值为 true 就能够使得该表达式的结果为 true。

在格式化输出时，你可以使用 `%t` 来表示你要输出的值为布尔型。就是把一个数值格式化为布尔型的数值，也就是只能用于两个对立条件的类型。

##  2 种数字类型——整型 int 和浮点型 float

### 整型 int 

回忆前文，所有类型的数值 之间的转化 都必须去化成同一种类型，要明面上去声明，不然不能计算。

就像是int16 也不能够被隐式转换为 int32

通过显式转换来避免这个问题

```go
package main

import "fmt"

func main() {
	var n int16 = 34
	var m int32
	// compiler error: cannot use n (type int16) as type int32 in assignment
	//m = n
	m = int32(n) //把n转化为类型是int32的m

	fmt.Printf("32 bit int is: %d\n", m)  //%d\n是一种占位符，十进制表示。
	fmt.Printf("16 bit int is: %d\n", n)
}
```

将会输出：

```
32 bit int is: 34
16 bit int is: 34
```



**格式化说明符**

在格式化字符串里，

`%d` 用于格式化整数，

`%x` 和 `%X` 用于格式化 16 进制表示的数字，

`%g` 用于格式化浮点型，

`%f` 输出浮点数，

`%e` 输出科学计数表示法，

`%0nd` 用于规定输出长度为n的整数，其中开头的数字 0 是必须的。例如`%03d`

`%n.mg` 用于表示数字 n 并精确到小数点后 m 位，除了使用 g 之外，还可以使用 e 或者 f，例如：使用格式化字符串 `%5.2e` 来输出 3.4 的结果为 `3.40e+00`。

## 4.5.2.2 复数

初中知识回顾:复数就是包含实数和虚数的东西。

Go 拥有以下复数类型：

	complex64 (32 位实数和虚数)
	complex128 (64 位实数和虚数)

复数使用 `re+imI` 来表示，其中 `re` 代表实数部分，`im` 代表虚数部分，

**I 代表根号负 1    (I是大写的i)，其实也能用小写的i表示。**

示例：

```go
var c1 complex64 = 5 + 10i
fmt.Printf("The value is: %v", c1) //这里的 %v是一种占位符表示相应值的默认格式。就是什么值就打印什么值，不把他格式化成其他的东西。
// 输出： 5 + 10i
```

如果 `re` 和 `im` 的类型均为 float32，那么类型为 complex64 的复数 c 可以通过以下方式来获得：

```go
c = complex(re, im)
```

函数 `real(c)` 和 `imag(c)` 可以分别获得相应的实数和虚数部分。



## 位运算

位运算 仅适用于，整数类型的运算，同时，位数要一样。

`%b`  是用于 表示   位  的  格式化标识符  。



1. **位与** （&） 类似**和**运算符 
2. **位或** （|）类似**或**运算符
3. **位异**  （^）参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。判断是否相同的符号。不同则答 是 ，相同则答 否

- 按 **位与**  `&`：

  **并将 T（true）替换为 1，将 F（false）替换为 0**。

  **下同**

  	1 & 1 -> 1  //这是类似 和 运算符
  	1 & 0 -> 0
  	0 & 1 -> 0
  	0 & 0 -> 0

- 按 **位 或** `|`：

  	1 | 1 -> 1  //这是类似 或
  	1 | 0 -> 1
  	0 | 1 -> 1
  	0 | 0 -> 0

- 按 **位异** 或 `^`：

  	1 ^ 1 -> 0   // 位异 参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。
  	//判断是否相同的符号。不同则答 是 ，相同则答 否
  	1 ^ 0 -> 1
  	0 ^ 1 -> 1
  	0 ^ 0 -> 0

- 位清除 `&^`：将指定位置上的值设置为 0。

# **一元运算符**

- 按位补足  `^`：

  与 异（用来判断是否不同的运算符） 或 运算符一同使用，

  即格式为 `m^x`时

  `^10` 里的^相当于一个占位符号，因为位运算只能算相同位数的，用^使数值位数变得一样。
  在默认情况下（无符号 x 使用，“全部位设置为 1”），相当于使后面的数值乘以一个 1 ，也就是`^10` 里的`^`前面多了个1，想到于上面提到的格式 `m^x` 之中的m=1。

  当x为负数时， `m^x` 之中的m=-1

  主要看这个例子。

  每一位都在每一位上加，就像是列了个加法竖式，十位和十位加，个位与各位加。

  但是是在二进制位上操作运算。

  	^10 = -01 ^ 10 = -11
  
- 位左移 `<<`：

  - 用法：`bitP << n`。

  - bitP指代任意数值。

  - `bitP` 的位向左移动 n 位，右侧空白部分使用 0 填充；

  - 假设 n 等于 2，则结果是 2 的相应倍数，即 2 的 n 次方。

  - 左移1位后bitP = bitP *2

  - 左移2位后bitP = bitP *2  *2

  - 依次类推，左移几位就乘2的几次方

  - 例如：

    	1 << 10 // 等于 1 KB ，1向左移动10位，相当于让原数乘以了2的10次方，这里的10，20，30都是十进制，但在位左移 <<操作下，是在二进制世界操作的。
    	1 << 20 // 等于 1 MB
    	1 << 30 // 等于 1 GB

- 位右移 `>>`：

  - 用法：`bitP >> n`。

  - `bitP` 的位向右移动 n 位，左侧空白部分使用 0 填充；如果 n 等于 2，则结果是当前值除以 2 的 n 次方。

    



# 看不懂↓↓↓↓↓↓↓↓↓↓↓↓

当希望把结果赋值给第一个操作数时，可以简写为 `a <<= 2` 或者 `b ^= a & 0xffffffff`。

# 看不懂↑↑↑↑↑↑↑↑↑↑↑↑





**位左移常见实现存储单位的用例**

**const** 的意思可以概括为 “一个不能被改变的普通变量”，这些固定值也称为文字。常量可以是任何基本数据类型

使用位左移与 iota 计数配合可优雅地实现存储单位的常量枚举：

```go
type ByteSize float64 //type是为常量赋值
const (       // const的意思可以概括为 “一个不能被改变的普通变量”，这些固定值也称为文字。常量可以是任何基本数据类型
	_ = iota // 通过赋值给空白标识符来忽略值，iota从0开始计数
	KB ByteSize = 1<<(10*iota) //<<是左位移的意思，此处，把1左移10*iota个单位，相当于乘2的几次方，向下几行就是iota的递加。
	MB
	GB
	TB
	PB
	EB
	ZB
	YB
)
```

**在通讯中使用位左移表示标识的用例**

```go
type BitFlag int
const (
	Active BitFlag = 1 << iota // 1 << 0 == 1
	Send // 1 << 1 == 2
	Receive // 1 << 2 == 4
)

flag := Active | Send // == 3   这个符号| 应该是 按位或 。在很多位的数字里面运算规律就是一位一位得判断，就是两个数，第一位进行按位或运算判断，然后第二位，第三位以此类推。比如5的二进制是 0101，3的二进制是 0011，然后先0|0判断，之后1|0判断，继而0|1判断，最后1|1判断。
//判断规律就是即  0 | 0= 0 ,  1 | 0= 1  ， 0 | 1= 1  ,  1 | 1= 1 
```

 **按位 或**  ——

在很多位的数字里面运算规律就是一位一位得判断，就是两个数，第一位进行按位或运算判断，然后第二位，第三位以此类推。

比如5的二进制是 0101，3的二进制是 0011，然后先0|0判断，之后1|0判断，继而0|1判断，最后1|1判断。
判断规律就是即  0 | 0= 0 ,  1 | 0= 1  ， 0 | 1= 1  ,  1 | 1= 1 



Go 中拥有以下逻辑运算符：`==`、`!=`(不等号)（第 4.5.1 节）、`<`、`<=`、`>`、`>=`。

它们之所以被称为逻辑运算符是因为它们的运算结果总是为布尔值 `bool`。例如：

```go
b3 := 10 > 5 // b3 is true
```

 ## 算术运算符

常见可用于整数和浮点数的二元运算符有 `+`、`-`、`*` 和 `/`。

`/` 对于整数运算而言，结果依旧为整数，例如：`9 / 4 -> 2`。

取余运算符只能作用于整数：`9 % 4 -> 1`。这里的%指的是9/4余数为1

整数除以 0 可能导致程序崩溃.

浮点数除以 0.0 会返回一个无穷尽的结果，使用 `+Inf` 表示。

## 运算符与优先级

有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：

	优先级 	运算符
	 7 		^ !
	 6 		* / % << >> & &^
	 5 		+ - | ^
	 4 		== != < <= >= >
	 3 		<-
	 2 		&&
	 1 		||

当然，你可以通过使用括号来临时提升某个表达式的整体运算优先级。



## 类型别名

可以给自己使用的类型，起一个，另外的名字。

然后在自己的代码里用新的名字。

在 `type TZ int` 中，TZ 就是 int 类型的新名称（用于表示程序中的时区），然后就可以使用 TZ 来操作 int 类型的数据。

示例 4.11 [type.go](examples/chapter_4/type.go)

```go
package main

import "fmt"

type TZ int  //将int类型起一个名字，名字为TZ

func main() {
	var a, b TZ = 3, 4  //为变量赋予类型和数值
	c := a + b  
	fmt.Printf("c has the value: %d", c) // 输出：c has the value: 7  
}
```

实际上，类型别名得到的新类型并非和原类型完全相同，新类型不会拥有原类型所附带的方法；

TZ 可以自定义一个方法用来输出更加人性化的时区信息。

