JSON，狗都会用。

通过把数据转换成纯文本，使用命名的字段来标注，让其具有可读性。这样的数据格式可以通过网络传输，而且是与平台无关的，任何类型的应用都能够读取和输出，不与操作系统和编程语言的类型相关。

## 下面是一些术语说明：

-   数据结构 --> 指定格式 = `序列化` 或 `编码`（传输之前）
-   指定格式 --> 数据格式 = `反序列化` 或 `解码`（传输之后）

此处的指定格式比如JSON，数据格式就好比Golang里的struct。

序列化是在内存中把数据转换成指定格式（data -> string），反之亦然（string -> data structure）

编码也是一样的，只是输出一个数据流（实现了 io.Writer 接口）；解码是从一个数据流（实现了 io.Reader）输出到一个数据结构。

## 与 XML 相同之处

-   JSON 是纯文本
-   JSON 具有"自我描述性"（人类可读）
-   JSON 具有层级结构（值中存在值）
-   JSON 可通过 JavaScript 进行解析
-   JSON 数据可使用 AJAX 进行传输

---

## 与 XML 不同之处

-   没有结束标签
-   更短
-   读写的速度更快
-   能够使用内建的 JavaScript eval() 方法进行解析
-   使用数组
-   不使用保留字

---

## 为什么使用 JSON？

对于 AJAX 应用程序来说，JSON 比 XML 更快更易使用：

#### 使用 XML

-   读取 XML 文档
-   使用 XML DOM 来循环遍历文档
-   读取值并存储在变量中

#### 使用 JSON

-   读取 JSON 字符串
-   用 eval() 处理 JSON 字符串


## JSON 语法规则

JSON 语法是 JavaScript 对象表示语法的子集。

-   数据在名称/值对中
-   数据由逗号分隔
-   大括号 {} 保存对象
-   中括号 [] 保存数组，数组可以包含多个对象

JSON 值可以是：

-   数字（整数或浮点数）
-   字符串（在双引号中）
-   逻辑值（true 或 false）
-   数组（在中括号中）
-   对象（在大括号中）
-   null

JSON 与 Go 类型对应如下：

-   bool 对应 JSON 的 boolean
-   float64 对应 JSON 的 number
-   string 对应 JSON 的 string
-   nil 对应 JSON 的 null
- 
不是所有的数据都可以编码为 JSON 类型：只有验证通过的数据结构才能被编码：

-   JSON 对象只支持字符串类型的 key；要编码一个 Go map 类型，map 必须是 map[string]T（T是 `json` 包中支持的任何类型）
-   Channel，复杂类型和函数类型不能被编码
-   不支持循环数据结构；它将引起序列化进入一个无限循环
-   指针可以被编码，实际上是对指针指向的值进行编码（或者指针是 nil）
## JSON到Golang 与 示例
JSON示例：
```json
{
	"name": "miku",
	"code": 111,
	"isABC": false,
	"today": "2021-08-13T12:56:49+08:00"
}
```
转化为Golang：
```go
type AutoGenerated struct {
	Name string `json:"name"`
	Code int `json:"code"`
	IsABC bool `json:"isABC"`
	Today time.Time `json:"today"`
}
```

再来一个复杂一点的例子，下面会写到详细的实现：
```JSON
{
    "FirstName": "Jan",
    "LastName": "Kersschot",
    "Addresses": [{
        "Type": "private",
        "City": "Aartselaar",
        "Country": "Belgium"
    }, {
        "Type": "work",
        "City": "Boom",
        "Country": "Belgium"
    }],
    "Remark": "none"
}
```
转换之后：
```go
type AutoGenerated struct {
	FirstName string `json:"FirstName"`
	LastName string `json:"LastName"`
	Addresses []Addresses `json:"Addresses"`
	Remark string `json:"Remark"`
}
type Addresses struct {
	Type string `json:"Type"`
	City string `json:"City"`
	Country string `json:"Country"`
}
```

来看这一行
>Addresses []Addresses \`json:"Addresses"\`
>JSON中的套娃数据在Go中表现为切片。

JSON中怎么套娃的：`[{}]`
```JSON
"Addresses": [{
        "Type": "private",
        "City": "Aartselaar",
        "Country": "Belgium"
    }]
```

## 从GO到JSON
实现会用到这个函数：
`func Marshal(v interface{}) ([]byte, error)`
输入空接口类型，输出[]byte(字节切片)
使用方法例如：`js, error := json.Marshal(v interface{})`

出于安全考虑，在 web 应用中最好使用 `json.MarshalforHTML()` 函数，其对数据执行HTML转码，所以文本可以被安全地嵌在 HTML `<script>` 标签中。

实现还会用到这个函数：
`func NewEncoder(w io.Writer) *Encoder`
返回的Encoder类型的指针可调用方法 `Encode(v interface{})`，将数据对象 v 的json编码写入 实现`io.Writer` 类型的参数 `w` 中。
使用方法例如：`enc := json.NewEncoder(file)`，返回一个Encoder类型的指针。

（我觉得吧，这更像是一个文件类型转换器，很多时候如此，把一个参数转化为某函数支持的类型。）

返回的Encoder类型的指针可调用方法`Encode(v interface{})`
函数签名为`func (enc *Encoder) Encode(v any) error`）
这里是把报错内容写到`err`里面去。

	err := enc.Encode(vc)
		func (enc *Encoder) Encode(v any) error
		Encode将v的JSON编码写入stream(流，组)，后跟一个换行符。
	if err != nil {
		log.Println("Error in encoding json")
	}
上面在defer file.Close()之后的代码，就是在为报错做准备。


回顾一下，调用接口就是实现接口里的所有方法。

完整代码如下：json.go
```go
// json.go
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
)

type Address struct {
	Type    string
	City    string
	Country string
}

type VCard struct {
	FirstName string
	LastName  string
	Addresses []*Address
	Remark    string
}

func main() {
	//三个马上就要被转化的例子
	pa := &Address{"private", "Aartselaar", "Belgium"}
	wa := &Address{"work", "Boom", "Belgium"}
	vc := VCard{"Jan", "Kersschot", []*Address{pa, wa}, "none"}
	// fmt.Printf("%v: \n", vc) // {Jan Kersschot [0x126d2b80 0x126d2be0] none}:
	// JSON format:
	//go到json
	js, _ := json.Marshal(vc) //func Marshal(v interface{}) ([]byte, error),输入空接口类型，输出[]byte(字节切片)
	fmt.Printf("JSON format: %s", js)
	// using an encoder:
	// 创建目标文件
	file, _ := os.OpenFile("vcard.json", os.O_CREATE|os.O_WRONLY, 0666)
	defer file.Close()
	//我觉得吧，这更像是一个文件类型转换器，很多时候如此，把一个参数转化为某函数支持的类型。
	//返回的Encoder类型的指针可调用方法Encode(v interface{})
	enc := json.NewEncoder(file)
	//方法 Encode(v interface{})会将数据对象 v 的json编码写入 io.Writer类型的参数w 中
	err := enc.Encode(vc)
	/*
		func (enc *Encoder) Encode(v any) error
		Encode将v的JSON编码写入stream(流，组)，后跟一个换行符。
	*/
	if err != nil {
		log.Println("Error in encoding json")
	}
//上面在defer file.Close()之后就是在为报错做准备。
}

```

## 反序列化：
上面的例子json.go，是struct到JSON。
也就是：
数据结构 --> 指定格式 = `序列化` 或 `编码`（传输之前）

要对其解码也就是：
指定格式 --> 数据格式 = `反序列化` 或 `解码`（传输之后）

思路是：
1. 创建结构 VCard 用来保存解码的数据：`var v VCard` 
2. 调用 `json.Unmarshal(js, &v)`，解析 []byte 中的 JSON 数据并将结果存入指针 &v 指向的值。
3. 要是JSON字段匹配不上就会被忽略。

用了 反射 的思路，WTM现在还玩不明白什么是反射。该学学了。

## 储存与解码任意数据。
### 储存
json包用
1. map[string]interface{} 字符串到空接口的键值对
2. []interface{} 空接口类型的slice
储存任意JSON数组。

被储存的JSON数组可以被反序列化为任何的 JSON blob 存储到接口值中。
.json文件转为json数据（对象），json数据（对象）转为Blob对象


来看这个 JSON 数据，被存储在变量 b 中：

```go
b := []byte(`{"Name": "Wednesday", "Age": 6, "Parents": ["Gomez", "Morticia"]}`)
```

`json.Unmarshal(js, &v)`，解析 []byte 中的 JSON 数据并将结果存入指针 &v 指向的值。
此处是把b中的JSON数据存到指针&f指向的值。
```go
var f interface{}
err := json.Unmarshal(b, &f)
```

f 指向的值是一个 map，key 是一个字符串，value 是自身存储作为空接口类型的值：

```go
map[string]interface{} {
	"Name": "Wednesday",
	"Age":  6,
	"Parents": []interface{} {
		"Gomez",
		"Morticia",
	},
}
```

要访问这个数据，我们可以使用类型断言（可以用来手动指定一个值的类型）
[类型断言 · Go语言圣经 (studygolang.com)](https://books.studygolang.com/gopl-zh/ch7/ch7-10.html)

```go
m := f.(map[string]interface{})
```

我们可以通过 for range 语法和 type switch 来访问其实际类型：

```go
for k, v := range m {
	switch vv := v.(type) {
	case string:
		fmt.Println(k, "is string", vv)
	case int:
		fmt.Println(k, "is int", vv)

	case []interface{}:
		fmt.Println(k, "is an array:")
		for i, u := range vv {
			fmt.Println(i, u)
		}
	default:
		fmt.Println(k, "is of a type I don’t know how to handle")
	}
}
```

通过这种方式，你可以处理未知的 JSON 数据，同时可以确保类型安全。


## 解码数据到结构

指定格式 --> 数据格式 = `反序列化` 或 `解码`（传输之后）

如果我们事先知道 JSON 数据，我们可以定义一个适当的结构并对 JSON 数据反序列化。

json长什么样就先搞一个跟他长得差不多的struct出来，然后json.Unmarshal(数据源，存储到的地方&m)，把JSON往里面填。
感觉没逼用。

下面的例子中，我们将定义：

```go
type FamilyMember struct {
	Name    string
	Age     int
	Parents []string
}

```

并对其反序列化：

```go
var m FamilyMember
err := json.Unmarshal(b, &m)
```

程序实际上是分配了一个新的切片。这是一个典型的反序列化引用类型（指针、切片和 map）的例子。

## 编码流和解码流
数据流定义为 “只能以事先规定好的顺序被读取一次的数据的一个序列”

json 包提供 Decoder 和 Encoder 类型来支持常用 JSON 数据流读写。

NewDecoder 和 NewEncoder 函数分别封装了 io.Reader 和 io.Writer 接口。

json包提供了`Marshal`和`json.Unmarshal(js, &v)`，从go到json（数据结构 --> 指定格式 = `序列化` 或 `编码`（传输之前））或反向操作（指定格式 --> 数据格式 = `反序列化` 或 `解码`（传输之后））。

把JSON写入文件，就是解码，用 NewEncoder 函数初始化文件（或者任何实现 io.Writer 的类型）。

编码相关的转格式要求就是NewDecoder 转化为 io.Reader 函数。

转格式的最终目的是用上`Marshal`和`json.Unmarshal(js, &v)`

原因如下，以解码为例。（JSON->GO）
:
`func NewEncoder(w io.Writer) *Encoder`
用 NewEncoder 函数初始化文件，返回`Encoder类型的指针`

返回的`Encoder类型的指针`可调用方法 `Encode(v interface{})`，（就是能作为v这个位置的输入值）

函数签名为`func (enc *Encoder) Encode(v any) error`

方法`Encode`意在将数据对象 v 的json编码写入 实现`io.Writer` 类型的参数 `w` 中。

方法`Encode`将v的JSON编码写入stream(流)

这个数据流会被利用，作为被以事先规定好的顺序被读取一次的数据的一个序列。

一个例子：

```go
	vc := VCard{"Jan", "Kersschot", []*Address{pa, wa}, "none"}
	//我觉得吧，这更像是一个文件类型转换器，很多时候如此，把一个参数转化为某函数支持的类型。
	//返回的Encoder类型的指针可调用方法Encode(v interface{})
	enc := json.NewEncoder(file)
	//方法 Encode(v interface{})会将数据对象 v 的json编码写入 io.Writer类型的参数w 中
	err := enc.Encode(vc) //enc是接收器
	/*
		func (enc *Encoder) Encode(v any) error
		Encode将vc的JSON编码写入stream(流)，后跟一个换行符。
	*/
	if err != nil {
		log.Println("Error in encoding json")
	}//写入流之后就能
//上面在defer file.Close()之后就是在为报错做准备。
```

接口是如何对实现进行抽象的：数据结构可以是任何类型，只要其实现了某种接口，目标或源数据要能够被编码就必须实现 io.Writer 或 io.Reader 接口。由于 Go 语言中到处都实现了 Reader 和 Writer，因此 Encoder 和 Decoder 可被应用的场景非常广泛，例如读取或写入 HTTP 连接、websockets 或文件。




